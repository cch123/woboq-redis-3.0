<def f='redis/src/scripting.c' l='69' ll='90' type='char * redisProtocolToLuaType(lua_State * lua, char * reply)'/>
<use f='redis/src/scripting.c' l='149' u='c' c='redisProtocolToLuaType_MultiBulk'/>
<use f='redis/src/scripting.c' l='400' u='c' c='luaRedisGenericCommand'/>
<doc f='redis/src/scripting.c' l='50'>/* Take a Redis reply in the Redis protocol format and convert it into a
 * Lua type. Thanks to this function, and the introduction of not connected
 * clients, it is trivial to implement the redis() lua function.
 *
 * Basically we take the arguments, execute the Redis command in the context
 * of a non connected client, then take the generated reply and convert it
 * into a suitable Lua type. With this trick the scripting feature does not
 * need the introduction of a full Redis internals API. Basically the script
 * is like a normal client that bypasses all the slow I/O paths.
 *
 * Note: in this function we do not do any sanity check as the reply is
 * generated by Redis directly. This allows us to go faster.
 * The reply string can be altered during the parsing as it is discarded
 * after the conversion is completed.
 *
 * Errors are returned as a table with a single &apos;err&apos; field set to the
 * error string.
 */</doc>
